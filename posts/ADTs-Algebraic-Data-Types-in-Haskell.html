<!DOCTYPE html>
<html lang="en"> <head> <title>Muhammad Attiyah - Home</title> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1"> <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Vidaloka"> <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Crimson+Text"> <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=IBM+Plex+Mono:500"> <link rel="stylesheet" href="http://muattiyah.com/css/normalize.css"> <link rel="stylesheet" href="http://muattiyah.com/css/style.css"> <link rel="alternate" href="http://muattiyah.com/rss.xml" type="application/rss+xml"> <script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-100940716-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script> </head> <body> <header> <a href="http://muattiyah.com"> <svg id="logo" viewBox="0 0 404.45 497.19"> <g transform="translate(-176.4 -169.51)"> <g transform="translate(-94.286 80)"> <path d="m492.29 89.506v184.29h182.86v-184.29h-182.86zm46.176 47.604h90.506v89.076h-90.506v-89.076z"/> <path d="m629.43 272.28v46.245h45.713v-46.245h-45.713z"/> <path d="m493.57 316.93h181.43v45.714h-181.43z"/> <path d="m493.57 361.93v138.57h45.714v-138.57h-45.714z"/> <path d="m630 360.22h44.286v226.47h-44.286z"/> <path d="m271.14 542.36h363.43v44.286h-363.43z"/> <path d="m271.07 497.01h44.286v45.714h-44.286z"/> <path d="m270.69 90.934v184.29h181.59v-184.29h-45.894v47.604h0.0369v89.076h-89.881v-89.076h0.11055v-47.604h-45.967z"/> <path d="m270.94 316.01v184.64h180.78v-184.64h-180.78zm45.65 47.696h89.476v89.249h-89.476v-89.249z"/> <path d="m270.86 272.28v46.245h45.713v-46.245h-45.713z"/> </g> </g> </svg> </a> </header> <h1 class="post-title">ADTs (Algebraic Data Types) in Haskell</h1> <div class="info"> 2018-05-30 </div> <div class="tags info">
Tagged as <a href="http://muattiyah.com/tag/haskell.html">haskell</a>, <a href="http://muattiyah.com/tag/programming.html">programming</a> </div>
<p>Algebraic Data Types are a way for us to define types like the ones that come with Haskell e.g. <code>Bool</code> and <code>Int</code>.</p>

<h2>Single Constructor Without Arguments</h2>

<p>The most simple data type we can construct in Haskell is a type with a single constructor,</p>

<pre><code><span class="code"><span class="keyword">data</span> <span class="variable">Frame</span> <span class="keyword">=</span> <span class="variable">MkFrame</span>
<span class="function">x</span> <span class="keyword">=</span> <span class="variable">MkFrame</span></span></code></pre>

<p>Examining the type in <code>ghci</code></p>

<pre><code>:&gt; :type MkFrame
MkFrame :: Frame

:&gt; :type x
x :: Frame</code></pre>

<p>In this example, we use the <code>data</code> keyword to signify a <strong>Data Type</strong>, <code>Frame</code> is the name of that type and we refer to it as a <strong>Type Constructor</strong>. <code>MkFrame</code> is called a <strong>Data Constructor</strong> and this is how we create new instances of the type <code>Frame</code>.</p>

<h2>Enums</h2>

<p>Enums (Enumeration Types), also referred to as <em>Sum Types</em> allow us to design a type that is reminiscent of a Logical OR. Suppose we want to have a type that will represent a day in the week, the day will be either Saturday, or Monday, or Tuesday, ...etc.</p>

<pre><code><span class="code"><span class="keyword">data</span> <span class="variable">Day</span> <span class="keyword">=</span> <span class="variable">Saturday</span> <span class="keyword">|</span> <span class="variable">Sunday</span> <span class="keyword">|</span> <span class="variable">Monday</span> <span class="keyword">|</span> <span class="variable">Tuesday</span> <span class="keyword">|</span> <span class="variable">Wednesday</span> <span class="keyword">|</span> <span class="variable">Thursday</span> <span class="keyword">|</span> <span class="variable">Friday</span>
<span class="function">day</span> <span class="keyword">=</span> <span class="variable">Tuesday</span></span></code></pre>

<p>Examining the type in <code>ghci</code></p>

<pre><code>:&gt; :type Saturday
Saturday :: Day

:&gt; :type day
pday :: Day</code></pre>

<h3>Pattern Matching</h3>

<p>We can pattern match on our data type like so:</p>

<pre><code><span class="code"><span class="function">dayNumber</span> <span class="keyword">::</span> <span class="variable">Day</span> <span class="keyword">-&gt;</span> <span class="variable">Int</span>
<span class="function">dayNumber</span> <span class="variable">Saturday</span>  <span class="keyword">=</span> 1
<span class="function">dayNumber</span> <span class="variable">Sunday</span>    <span class="keyword">=</span> 2
<span class="function">dayNumber</span> <span class="variable">Monday</span>    <span class="keyword">=</span> 3
<span class="function">dayNumber</span> <span class="variable">Tuesday</span>   <span class="keyword">=</span> 4
<span class="function">dayNumber</span> <span class="variable">Wednesday</span> <span class="keyword">=</span> 5
<span class="function">dayNumber</span> <span class="variable">Thursday</span>  <span class="keyword">=</span> 6
<span class="function">dayNumber</span> <span class="variable">Friday</span>    <span class="keyword">=</span> 7</span></code></pre>

<p>or using a <code>case of</code> statement:</p>

<pre><code><span class="code"><span class="function">dayNumberCase</span> <span class="keyword">::</span> <span class="variable">Day</span> <span class="keyword">-&gt;</span> <span class="variable">Int</span>
<span class="function">dayNumberCase</span> x <span class="keyword">=</span>
&nbsp; <span class="keyword">case</span> x <span class="keyword">of</span>
&nbsp;   <span class="variable">Saturday</span>  <span class="keyword">-&gt;</span> 0
&nbsp;   <span class="variable">Sunday</span>    <span class="keyword">-&gt;</span> 2
&nbsp;   <span class="variable">Monday</span>    <span class="keyword">-&gt;</span> 3
&nbsp;   <span class="variable">Tuesday</span>   <span class="keyword">-&gt;</span> 4
&nbsp;   <span class="variable">Wednesday</span> <span class="keyword">-&gt;</span> 5
&nbsp;   <span class="variable">Thursday</span>  <span class="keyword">-&gt;</span> 6
&nbsp;   <span class="variable">Friday</span>    <span class="keyword">-&gt;</span> 7</span></code></pre>

<h2>Constructors with arguments</h2>

<p>We can also declare types whose constructor takes one or more arguments, these are commonly referred to as <em>Product Types</em>. Let's say we want to represent a point in the cartesian coordinate system i.e. a point with <code>x</code> and <code>y</code> coordinates,</p>

<pre><code><span class="code"><span class="keyword">data</span> <span class="variable">Point</span> <span class="keyword">=</span> <span class="variable">P</span> <span class="variable">Int</span> <span class="variable">Int</span>
<span class="function">mypoint</span> <span class="keyword">=</span> <span class="variable">P</span> 1 2</span></code></pre>

<p>Examining in <code>ghci</code></p>

<pre><code>:&gt; :type P
P :: Int -&gt; Int -&gt; Point

:&gt; :type mypoint
mypoint :: Point

:&gt; :type P 1 2
P 1 2 :: Point</code></pre>

<p>It's a convention in Haskell code to sometimes label the data constructor with the same label as the type constructor, to illustrate this with our <code>Point</code> example:</p>

<pre><code><span class="code"><span class="keyword">data</span> <span class="variable">Point</span> <span class="keyword">=</span> <span class="variable">Point</span> <span class="variable">Int</span> <span class="variable">Int</span>
<span class="function">mypoint</span> <span class="keyword">=</span> <span class="variable">Point</span> 1 2</span></code></pre>

<h2>Record Syntax</h2>

<p>Let's say we want to define a <code>User</code> type that has the <code>name</code> and <code>age</code> of a user, we can try to do something like this</p>

<pre><code><span class="code"><span class="keyword">data</span> <span class="variable">User</span> <span class="keyword">=</span> <span class="variable">User</span> <span class="variable">String</span> <span class="variable">Int</span></span></code></pre>

<p>where <code>name</code> is of type <code>String</code> and <code>age</code> is of type <code>Int</code>. However, in our application, we will want to get the name and age from an instance of this data type, we can do this like so:</p>

<pre><code><span class="code"><span class="function">getName</span> <span class="keyword">::</span> <span class="variable">User</span> <span class="keyword">-&gt;</span> <span class="variable">String</span>
<span class="function">getName</span> <span class="paren1">(<span class="code"><span class="variable">User</span> name _</span>)</span> <span class="keyword">=</span> name

<span class="function">getAge</span> <span class="keyword">::</span> <span class="variable">User</span> <span class="keyword">-&gt;</span> <span class="variable">Int</span>
<span class="function">getAge</span> <span class="paren1">(<span class="code"><span class="variable">User</span> _ age</span>)</span> <span class="keyword">=</span> age</span></code></pre>

<p>but, as you can imagine, this would get too daunting and verbose if our data constructor takes a large number of arguments, and we'll have to modify all these accessor functions
if we add or remove arguments from the data constructor. Also, we have to keep in mind the position of each argument. Enter records, records allow us to write:</p>

<pre><code><span class="code"><span class="keyword">data</span> <span class="variable">User</span> <span class="keyword">=</span> <span class="variable">User</span>
&nbsp; <span class="paren1">{<span class="code"> name  <span class="keyword">::</span> <span class="variable">String</span>
&nbsp; , age   <span class="keyword">::</span> <span class="variable">Int</span>
&nbsp; </span>}</span>

<span class="comment">-- Create a User</span>
<span class="function">user1</span> <span class="keyword">=</span> <span class="variable">User</span>
&nbsp; <span class="paren1">{<span class="code"> name <span class="keyword">=</span> <span class="string">"Oliver Heaviside"</span>
&nbsp; , age <span class="keyword">=</span> 74
&nbsp; </span>}</span>

<span class="comment">-- This still works</span>
<span class="function">user2</span> <span class="keyword">=</span> <span class="variable">User</span> <span class="string">"James Clerk Maxwell"</span> 48</span></code></pre>

<p>and get accessor functions for free, these will be automagically generated:</p>

<pre><code><span class="code"><span class="function">name</span> <span class="keyword">::</span> <span class="variable">User</span> <span class="keyword">-&gt;</span> <span class="variable">String</span>
<span class="function">age</span> <span class="keyword">::</span> <span class="variable">User</span> <span class="keyword">-&gt;</span> <span class="variable">Int</span></span></code></pre>

<p>We also get a nice field update syntax</p>

<pre><code><span class="code"><span class="function">changeAge</span> user newAge <span class="keyword">=</span> user <span class="paren1">{<span class="code"> age <span class="keyword">=</span> newAge</span>}</span>

<span class="function">user1</span> <span class="keyword">=</span> <span class="variable">User</span>
&nbsp; <span class="paren1">{<span class="code"> name <span class="keyword">=</span> <span class="string">"Oliver Heaviside"</span>
&nbsp; , age <span class="keyword">=</span> 74
&nbsp; </span>}</span>

<span class="function">newuser</span> <span class="keyword">=</span> changeAge user1 42</span></code></pre>

<h3>Record Downsides</h3>

<p>Unfortunately records have some issues, refer to <a href="https://ghc.haskell.org/trac/ghc/wiki/Records" title="Issues with records in Haskell">this</a> for more details.</p>

<h2>Parametrized Types</h2>

<p>Type constructors can be parametrized with types, the standard <code>Prelude</code> library define the <code>Maybe</code> type:</p>

<pre><code><span class="code"><span class="keyword">data</span> <span class="variable">Maybe</span> a <span class="keyword">=</span> <span class="variable">Nothing</span> <span class="keyword">|</span> <span class="variable">Just</span> a</span></code></pre>

<p>Here, <code>Maybe</code> is parametrized with the generic type <code>a</code> which can take on any type, this is a bit like <strong>Generics</strong> in other languages. The <code>Maybe</code> type
allows us to express the nonexistence of a value, for example when trying to take the head of a list, instead of erroneously applying head to an empty
list, we can defend against this:</p>

<pre><code><span class="code"><span class="function">lhead</span> <span class="keyword">::</span> <span class="paren1">[<span class="code">a</span>]</span> <span class="keyword">-&gt;</span> <span class="variable">Maybe</span> a
<span class="function">lhead</span> <span class="paren1">[<span class="code"></span>]</span> <span class="keyword">=</span> <span class="variable">Nothing</span>
<span class="function">lhead</span> xs <span class="keyword">=</span> <span class="variable">Just</span> <span class="paren1">(<span class="code">head xs</span>)</span></span></code></pre>

<p>And, playing around in <code>ghci</code></p>

<pre><code>:&gt; :type lhead []
lhead [] :: Maybe a

:&gt; :type lhead ['a']
lhead ['a'] :: Maybe Char

:&gt; :type lhead [1]
lhead [1] :: Num a =&gt; Maybe a</code></pre>

<h2>Recursive Types</h2>

<p>Haskell allows us to define types in terms of themselves <em>recursive types</em>. Let's illustrate this by making a type for a <strong>Binary Tree</strong>:</p>

<pre><code>data BinTree a = EmptyTree
               | Node a (BinTree a) (BinTree a)

mytree = Node 1 EmptyTree EmptyTree</code></pre>

<p>Here, we constructed <code>mytree</code> to be a tree with a single node, with an empty left and right subtrees. We can also construct a tree with 3 nodes:</p>

<pre><code><span class="code"><span class="function">mytree2</span> <span class="keyword">=</span> <span class="variable">Node</span> 1 <span class="paren1">(<span class="code"><span class="variable">Node</span> 2 <span class="variable">EmptyNode</span> <span class="variable">EmptyNode</span></span>)</span> <span class="paren1">(<span class="code"><span class="variable">Node</span> 3 <span class="variable">EmptyNode</span> <span class="variable">EmptyNode</span></span>)</span></span></code></pre>
  <br /> <br /> <hr> <footer> <a href="http://muattiyah.com/atom.xml">Atom Feed</a> <a href="http://muattiyah.com/rss.xml">RSS Feed</a> </footer> </body> </html>